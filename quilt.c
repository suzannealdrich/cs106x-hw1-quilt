/* * * File:  quilt.c * Author:  Suzanne Aldrich * Date:  10/3/97 * --------------- * Program that draws a funky fractal sampler quilt. * */#include <stdio.h>#include "genlib.h"#include "extgraph.h"/* Definitions for the entire quilt *///  Number of recursions through DrawQuilt() function; limited by smallest pointsize available.#define MAXRECURSIONLEVEL 1 //  Pre-processor replaces constant "BlockSize" with "scale * 0.75"; //  (other constants don't need to be scaled because they are defined in terms of BlockSize).#define BLOCK_SIZE (scale * 0.75) //  Initial scale factor of BLOCK_SIZE. #define INIT_SCALE 1.5 #define NUM_BLOCKS 5/* Definitions for the Log Cabin block */#define NUM_FRAMES 4#define FRAME_WIDTH  BLOCK_SIZE/((NUM_FRAMES*2) +1)#define MAX_DENSITY 1.0#define DENSITY_STEP 0.15/* Local function declarations *//*  DrawQuilt() is the function which places the quilt blocks in their appropriate positions. *  This is a recursive function; it calls itself with new scale and recursionLevel parameters *  in order to adjust the size of the little quilts. */void DrawQuilt(double xoffset, double yoffset, double scale, int recursionLevel);void DrawLogCabin(double x, double y, double scale, double frames, string color);void DrawFilledBox(double x, double y, double dx, double dy, int framelayer);	void DrawBox(double x, double y, double dx, double dy);/* Implementation */main(){		double xoffset = 0, yoffset = 0, scale = INIT_SCALE;		SetWindowSize(NUM_BLOCKS * BLOCK_SIZE * 1.02, NUM_BLOCKS * BLOCK_SIZE * 1.02);    InitGraphics();    SetWindowTitle("Please Wait While Your Incredibly Slow Graphics Library Calculates...");    DefineColor("Purpleish", 207/255., 157/255., 255/255.);    DefineColor("Greenish", 157/255., 255/255., 201/255.);    DefineColor("Grayish", 157/255., 157/255., 157/255.);    DefineColor("Dark Grayish", 103/255., 103/255., 103/255.);        //  Offsets are calculated once; dependant on screensize.    xoffset = (GetWindowWidth() - BLOCK_SIZE * NUM_BLOCKS) / 2;      yoffset = (GetWindowHeight() - BLOCK_SIZE * NUM_BLOCKS) / 2; 	    //  Oth recursion:  draws centered outer quilt with INIT_SCALE.    //  nth recursion:  draws entire quilt inside of custom block with recursion-adjusted scale.    DrawQuilt(xoffset, yoffset, scale, 0);        SetWindowTitle("Aigeanta's Quilt");    printf("Created by Suzanne Aldrich.\n  aigeanta@stanford.edu\n");}void DrawQuilt(double xoffset, double yoffset, double scale, int recursionLevel){    int row, col;	double x, y;		//  Since DrawQuilt() calls itself, it has to test for recursions beyond the limit. 	    if (recursionLevel > MAXRECURSIONLEVEL) return;             for (row = 0; row < NUM_BLOCKS; row++)    {    	y = row * BLOCK_SIZE + yoffset;  //  BLOCK_SIZE is scaled each recursion.    	    	for (col = 0; col < NUM_BLOCKS; col++)    	{	    		x = col * BLOCK_SIZE + xoffset;     		    		//  Block type is dependent on its row/column position in the quilt.    		//  Cycles through block type via mod operator.    		switch ( (row + col) % NUM_BLOCKS) {      		case 0:    			DrawLogCabin(x, y, scale, NUM_FRAMES, "Purpleish");     			break;    		case 1:    		    DrawLogCabin(x, y, scale, NUM_FRAMES, "Greenish");    			break;    		case 2:    			DrawLogCabin(x, y, scale, NUM_FRAMES, "Purpleish");     			break;    		case 3:    			DrawLogCabin(x, y, scale, NUM_FRAMES, "Greenish");     			break;    		case 4:    			//  Recursion: quilt scaled down by NUM_BLOCKS to fit in block.    			//  Calls itself with next recursion level.    			DrawQuilt(x, y, scale / NUM_BLOCKS, recursionLevel + 1);      			break;    		}    		    		//  Outline each block    		//SetPenColor("Black");    		//DrawBox(x, y, BLOCK_SIZE, BLOCK_SIZE);    		UpdateDisplay();    	}    }}void DrawLogCabin(double x, double y, double scale, double frames, string color){	int framelayer;	double FrameLength = 0;			for (framelayer = 0; framelayer < frames; framelayer++)	{		double offset = framelayer * FRAME_WIDTH;  //  Offset increases at each frame layer.				FrameLength = BLOCK_SIZE - ((2 * (framelayer + 1) - 1) * FRAME_WIDTH);  //  Frameboxes get shorter closer to center of block.				//  Draw each box from each of the four corners of current framelayer.		//  Width and height of box positive or negative depending on corner from which it is drawing.	    SetPenColor(color);		DrawFilledBox(x + offset, y + offset, FrameLength, FRAME_WIDTH, framelayer);		SetPenColor(color);		DrawFilledBox(x + offset, y + BLOCK_SIZE - offset, FRAME_WIDTH, -FrameLength, framelayer);		SetPenColor(color);		DrawFilledBox(x + BLOCK_SIZE - offset, y + BLOCK_SIZE - offset, -FrameLength, -FRAME_WIDTH, framelayer);		SetPenColor(color);		DrawFilledBox(x + BLOCK_SIZE - offset, y + offset, -FRAME_WIDTH, FrameLength, framelayer);	}}//  Draws shaded rectangular region and then outlines it.void DrawFilledBox(double x, double y, double dx, double dy, int framelayer){		StartFilledRegion(MAX_DENSITY - framelayer * DENSITY_STEP);	DrawBox(x, y, dx, dy);	EndFilledRegion();	SetPenColor("Grayish");	DrawBox(x, y, dx, dy);}/*  Draws box from any corner; *  lower left:   + width, + height  (Quadrant 1) *  upper left:   + width, - height  (Quadrant 4) *  upper right:  - width, - height  (Quadrant 3) *  lower right:  - width, + height  (Quadrant 2) *  Arguments are an origin and a vector to the opposite corner. */void DrawBox(double x, double y, double dx, double dy){	MovePen(x, y);	DrawLine(dx, 0);	DrawLine(0, dy);	DrawLine(-dx, 0);	DrawLine(0, -dy);}/*  Credits: *  -------- *  Thanks to dl@acm.org for recursion implementation advice. */